# 3주차 과제

## Step 1 구현 목록

- 첨부된 `oas.yaml` 파일을 토대로 Request, Response Type을 정의해요.
- React Query를 사용하지 말고 axios 를 사용해서 구현해요.
- 첨부된 `oas.yaml` 파일과 목 API URL을 사용하여 API를 구현해요.
    - 메인 페이지 - Theme 카테고리 섹션
        - `/api/v1/themes` API를 사용하여 Section을 구현해요.
        - API는 Axios또는 React Query 등을 모두 활용해서 구현해도 좋아요.
    - 메인 페이지 - 실시간 급상승 선물랭킹 섹션
        - `/api/v1/ranking/products` API를 사용하여 Section을 구현해요. (Axios 사용 가능)
        - 필터 조건을 선택 하면 해당 조건에 맞게 API를 요청하여 보여지게 해요.
    - Theme 페이지 - header
        - url의 pathParams와 `/api/v1/themes` API를 사용하여 Section을 구현해요.
        - `themeKey`가 잘못 된 경우 메인 페이지로 연결해요.
    - Theme 페이지 - 상품 목록 섹션
        - `/api/v1/themes/{themeKey}/products` API를 사용하여 상품 목록을 구현해요.
        - API 요청 시 한번에 20개의 상품 목록이 내려오도록 해요.
## step 2 
- 각 API에서 Loading 상태에 대한 UI 대응을 해요.
- 데이터가 없는 경우에 대한 UI 대응을 해요.
- Http Status에 따라 Error를 다르게 처리해요.

## step 3
- 스크롤을 내리면 추가로 데이터를 요청하여 보여지게 해요.
- 1단계에서 구현한 API를 react-query를 사용해서 구현해봐요.

## step 4
### 질문 1. CORS 에러는 무엇이고 언제 발생하는지 설명해주세요. 이를 해결할 수 있는 방법에 대해서도 설명해주세요.
`CORS 에러란?`
웹 어플리케이션이 한 출처에서 실행 중인 리소스가 다른 출처의 리소스에 접근하려고 할 때 발생한다. 

`구체적인 예시`
1. 웹 페이지가 다른 도메인, 포트, 프로토콜에 있는 리소스에 접근하려고 할 때
2. 웹 애플리케이션이 서버에 HTTP 요청을 보낼 때 서버가 올바른 CORS 헤더를 포함하지 않은 경우

`해결방법`
1. 서버에 CORS 헤더 추가
2. OPTION 요청 허용
3. CORS 미들웨어 사용

### 질문 2. 비동기 처리 방법인 callback, promise, async await에 대해 각각 장단점과 함께 설명해주세요.

`Callback`
장점
- 간단하고 직관적이다.
- 즉각적인 비동기 처리를 가능하게 한다
단점
- 콜백 지옥 또는 중첩된 콜백으로 인해 코드가 복잡해지고 가독성이 떨어진다.
- 에러 처리가 어렵다

`Promise`
장점
- 콜백 지옥 피할 수 있다.
- 체이닝을 통해 가독성을 향상 시킨다.
- 일관된 에러 처리가 가능하다.(`.catch()` 메서드 사용)
단점
- 초기 학습 곡선이 있다.
- 코드가 복잡해질 수 있다.

`Async/Await`
장점
- 동기식 코드처럼 읽히므로 가독성이 좋다
- 에러 처리가 간편하다(`try...catch`)
단점
- 구형 브라우저에서 지원하지 않으며, 트랜스파일이 필요할 수 있다
- promise와 마찬가지로 복잡해질 수 있다.

### 질문 3. react query의 주요 특징에 대해 설명하고, queryKey는 어떤 역할을 하는지 설명해주세요.
React Query의 주요 특징
React Query는 서버 상태를 관리하는 라이브러리로, 데이터 페칭, 캐싱, 동기화, 서버 상태 업데이트 등의 기능을 제공한다.

1. 자동화된 데이터 페칭과 캐싱:
서버에서 데이터를 자동으로 페칭하고, 데이터를 캐싱하여 성능을 최적화합니다.

2. 배경 데이터 업데이트:
사용자가 보는 데이터를 백그라운드에서 자동으로 업데이트합니다.

3. 쿼리 무효화와 리패치:
데이터가 변경되었을 때 쿼리를 무효화하고 자동으로 데이터를 다시 가져옵니다.

4. 간편한 에러와 로딩 상태 관리:
데이터 페칭 중의 로딩 상태와 에러 상태를 쉽게 관리할 수 있습니다.

5. 페이지네이션과 무한 스크롤 지원:
복잡한 페이지네이션과 무한 스크롤 기능을 간단하게 구현할 수 있습니다.

6. React DevTools 지원:
React Query DevTools를 사용하여 쿼리 상태를 시각적으로 디버깅할 수 있습니다.

`queryKey의 역할`
queryKey는 React Query에서 각 쿼리를 식별하는 고유한 키이다. 
1. 캐싱: queryKey를 기준으로 데이터를 캐싱한다. 동일한 queryKey를 가진 쿼리는 동일한 데이터를 공유한다.
2. 데이터 무효화와 리패치: 특정 queryKey를 가진 쿼리를 무효화하고 다시 페칭할 수 있다.
3. 동일한 쿼리 방지: queryKey를 통해 동일한 쿼리가 중복으로 실행되지 않도록 방지한다.
4. 쿼리 구별: 다양한 데이터 소스를 구별할 때 사용된다. 예를 들어, 사용자 목록과 제품 목록은 각기 다른 queryKey를 가질 수 있다.