### 1단계 기능 요구사항

- React-Query를 사용하지 말고 axios를 사용해서 구현
- 첨부된 **`oas.yaml`** 파일과 mock API URL을 사용하여 API 구현

- [x] 첨부된 **`oas.yaml`** 파일을 토대로 Request, Response Type 정의
- 메인 페이지 - Theme 카테고리 섹션
  - [x] **`/api/v1/themes`** API를 사용하여 Section을 구현
- 메인 페이지 - 실시간 급상승 선물랭킹 섹션
  - [x] **`/api/v1/ranking/products`** API를 사용하여 Section 구현
  - [x] 필터 조건을 선택하면 해당 조건에 맞게 API 요청
- Theme 페이지 - header
  - [x] url의 pathParams와 **`/api/v1/themes`** API를 사용하여 Section 구현
  - [x] **`themeKey`**가 잘못된 경우, 메인 페이지로 연결
- Theme 페이지 - 상품 목록 섹션
  - [x] **`/api/v1/themes/{themeKey}/products`** API를 사용하여 상품 목록 구현
  - [x] API 요청 시, 한 번에 20개의 상품 목록이 내려오도록 구현

### 2단계 기능 요구사항

- Loader 표시
  - [x] Loader 컴포넌트 생성
  - [x] GoodsRanking에서 Loading 상태인 경우, 로더 표시
  - [x] ThemeGoods에서 Loading 상태인 경우, 로더 표시
- 데이터가 없는 경우
  - [x] GoodsRanking에서 “보여줄 상품이 없어요!” 메시지 표시
  - [x] ThemeGoods에서 “상품이 없어요.” 메시지 표시
- Http Status에 따라 Error를 다르게 처리
  - [x] GoodsRanking에서 에러 처리
  - [x] ThemeGoods에서 에러 처리

### 3단계 기능 요구사항

- [x] 1단계에서 구현한 API를 react-query를 사용해서 구현
- [x] 스크롤을 내리면 추가로 데이터를 요청하여 보이기 (무한 스크롤)

### 4단계 질문 목록

1. **CORS 에러는 무엇이고 언제 발생하는지 설명해주세요. 이를 해결할 수 있는 방법에 대해서도 설명해주세요.**

   CORS는 Cross-Origin-Resource Sharing의 약자로, 직역하면 ‘교차 출처 리소스 공유 정책’ 정도로 해석할 수 있습니다.

   여기서 말하는 출처란, URL의 Protocol + Host + Port 부분입니다. URL에서 이 세 구성 요소가 모두 같다면 브라우저는 동일한 출처로 간주합니다.

   브라우저에서는 동일한 출처에서만 리소스를 공유할 수 있다는 ‘동일 출처 정책(Same-Origin Policy)’이 존재합니다. 동일 출처 서버에 있는 리소스는 자유롭게 사용 가능하지만, 다른 출처 서버에 있는 리소스는 상호작용이 불가합니다. 이는 해커가 CSRF나 XSS 등의 방법을 이용해서 개인정보를 가로채는 경우를 방지하기 위한 정책입니다.

   이러한 브라우저의 동일 출처 정책에 의해 웹 페이지가 다른 출처의 API에 요청을 보낼 때, CORS 에러가 발생합니다.

   출처를 비교하고 차단하는 행위는 브라우저에서 수행하기 때문에 브라우저 정책에서 SOP 정책을 비활성화 하면 해결할 수 있습니다. 그러나 위에서 언급한 보안 상의 문제 때문에 권장하지 않는 방법입니다.

   그보다는 서버 측에서 특정 도메인 또는 모든 도메인에서 오는 요청을 허용하도록 CORS 설정을 추가하는 방법이 좋습니다. 이는 서버 응답 헤더에 `Access-Control-Allow-Origin` 헤더를 설정함으로써 가능합니다.

2. **비동기 처리 방법인 callback, promise, async await에 대해 각각 장단점과 함께 설명해주세요.**

   | 처리 방법 | callback                                            | promise                                                                                          | async await                                                                                           |
   | --------- | --------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------- |
   | 설명      | 특정 작업이 완료된 이후에 호출되는 함수.            | 비동기 작업의 최종 완료/실패를 나타내는 객체.                                                    | Promise 기반으로 동작하며, 동기적 처리 방식으로 작성 가능.                                            |
   | 장점      | 간단하고 직관적이며, 빠르게 구현 가능하다.          | 콜백 지옥을 방지할 수 있으며, then 체인을 이용해 순차적으로 처리 가능하다. 에러 처리가 용이하다. | 가독성이 높으며, 동기 코드처럼 직관적으로 작성할 수 있다. try/catch 문을 이용해 에러 처리가 용이하다. |
   | 단점      | 콜백 지옥이 발생할 수 있으며, 에러 처리가 복잡하다. | 문법이 다소 복잡하고, 초기 학습 비용이 높다….                                                    | 구형 브라우저에서는 지원하지 않을 수 있으며, promise 기반이므로 초기 학습 비용이 존재한다.            |

3. **react query의 주요 특징에 대해 설명하고, queryKey는 어떤 역할을 하는지 설명해주세요.**

   react-query는 주로 데이터 요청 및 상태 관리를 처리하기 위해 사용됩니다. 기존의 상태 관리 라이브러리(Redux 등)와 달리, 데이터를 가져오고 캐싱하는 데에 초점을 맞추고 있습니다. 이를 통해 중복된 요청을 최소화하고, 서버와의 통신을 최적할 수 있습니다.

   react-query는 훅 기반의 API를 제공합니다. 예를 들어, `useQuery` , `useMutation` , `useQueryClient` 등의 훅을 사용하여 데이터 요청 및 상태 관리를 처리합니다. 또한, 쿼리의 상태 변화를 추적하고 캐싱된 데이터를 자동을 갱신하며, 오류 처리 및 재시도 로직을 제공합니다.

   react-query에서 제공하는 hooks인 `useQuery` 와 `useMutation` 을 사용하면 해당 hooks의 `queryKey` 를 지정하게 됩니다. react-query에서는 `queryKey` 를 기반으로 쿼리 캐싱을 관리합니다.
