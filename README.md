# 카카오 테크 캠퍼스 3주차: 상품 리스트 구현 - api 미션

## 1 & 2단계 - API 적용하기 (Axios) & Error, Loading Status 핸들링하기

- [x] 첨부된 oas.yaml 파일과 목 API URL을 사용하여 비동기 통신 구현 (axios로만)
- [x] Loading, Error 처리하고 UI 대응

## 3단계 - 테마 별 선물 추천 API에 페이지네이션 구현하기 & React Query 사용해보기

- [x] 리액트 쿼리로 비동기 통신 커스텀 훅 사용
- [ ] 무한 스크롤 구현

## 4단계 - 질문의 답변

### 질문 1.

CORS 에러는 무엇이고 언제 발생하는지 설명해주세요. 이를 해결할 수 있는 방법에 대해서도 설명해주세요.

> CORS 에러: **다른 출처(origin)의 리소스에 접근하는 것을 제한**하는 브라우저 보안 메커니즘이다.  
> 출처는 프로토콜(HTTP/HTTPS), host, port를 합친 것이며, 요청할 주소와 실행 중인 웹 주소가 이중 하나라도 다를 경우 접근이 제한된다. 또 특정 HTTP 요청 메서드 또는 커스텀 헤더를 포함하여 요청 시에도 CORS 에러가 발생할 수 있다.

> 해결 방법:
>
> 1. 서버 측 설정: 미들웨어 등을 사용하여 요청을 허용할 출처(origin), 허용할 HTTP 메서드 및 헤더를 설정 가능
> 2. 프록시 서버: CORS 정책을 무시하고 임의로 우회하는 것이므로 권장되지 않음
> 3. Vercel이나 Netlify 같은 정적 리소스 호스팅 서비스 활용: CORS 문제를 알아서 관리

### 질문 2.

비동기 처리 방법인 callback, promise, async await에 대해 각각 장단점과 함께 설명해주세요.

> **callback 함수**: JS의 기본적인 비동기 처리 패턴  
> 장점
>
> 1. 모든 JS 환경에서 지원하며, 오래된 코드에서도 사용
>
> 단점
>
> 1. 콜백 헬 (여러 비동기 작업이 있으면 중첩 코드 많아지는 문제)  
>    콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또 다시 비동기 함수를 호출하면...
> 2. 이로 인해 에러 처리 어려움

> **Promise**: 콜백 헬을 해결하기 위해 ES6에서 도입되었다.  
> 장점
>
> 1. 후속 처리 메서드(then, catch, finally)로 후속 동작 처리 가능
> 2. 체이닝을 통해 비동기 작업을 순차적으로 처리 가능
> 3. catch를 사용하여 에러 처리 로직 간편화
>
> 단점
>
> 1. 문법이 조금 복잡할 수 있음

> **async/await**: 프로미스 문법 기반이며 ES8에서 도입되었다. await 키워드는 반드시 async 함수 내부에서만 사용할 수 있다.  
> 장점
>
> 1. 비동기 코드를 동기 코드처럼 작성할 수 있어 가독성 향상
> 2. try/catch로 에러 처리 일관성 있음
>
> 단점
>
> 1. 최신 문법이므로 오래된 JS 환경에서 미지원

> 따라서 순차적 처리가 필요한지 아닌지(앞의 연산 결과를 뒤에 코드가 사용하는지 아닌지)에 따라 async/await 또는 프로미스를 선택하는 것이 좋다.

### 질문 3.

react query의 주요 특징에 대해 설명하고, queryKey는 어떤 역할을 하는지 설명해주세요.

> React Query:  
> **서버 상태 관리 라이브러리**이며,  
> 과거에는 react-query로 설치했지만 현재 tanstack이라는 네임 스페이스 아래 통합 관리되고 있어 @tanstack/react-query로 설치 가능하다.
>
> 장점
>
> 1. 전역 상태 중에서도 서버 상태만 클라이언트 상태와 분리하여 관리 가능
> 2. 자동 데이터 페칭 및 캐싱을 지원
> 3. useQuery를 지원하므로 비동기 데이터 페칭 및 변이 작업을 간단하게 처리
> 4. React Query DevTools 제공하므로 쿼리 상태, 캐시 데이터, 리페칭 상태를 확인 및 디버깅 가능
> 5. 옵티미스틱 업데이트 및 실시간 데이터 업데이트 처리: 서버에 데이터가 성공적으로 저장되기 전에 UI를 먼저 업데이트해 사용자에게 빠른 피드백을 제공, 또한 폴링이나 웹소켓으로 실시간 데이터를 간단하게 관리
>
> 그러나 리덕스나 주스탠드 등의 완전한 대체제가 될 수는 없다. 비동기 데이터 페칭에 특화되어 있어 클라이언트 상태 로직을 처리하기에는 부족하기 때문이다.  
> 클라이언트 상태(테마, 언어, 임시 데이터 등)는 상태 관리 라이브러리, 서버 상태(비동기 데이터)는 리액트 쿼리를 사용하면 로직이 깔끔해질 것 같다.

> queryKey 역할:  
> **각 쿼리를 고유하게 식별**하는 역할을 하며, 데이터 페칭과 캐싱 로직에 관여한다.
>
> 1. 캐싱 식별자: 기존에 있는 쿼리 키와 똑같은 키를 사용하면 이미 데이터가 캐싱되어 있으므로 해당 데이터를 재사용
> 2. 데이터 동기화: 쿼리 키를 통해 데이터 자동 업데이트 가능. 전역 상태로 관리하는 것처럼 한 컴포넌트에서 업데이트되면 다른 컴포넌트에서도 최신 데이터를 이용가능한 것
> 3. 쿼리 무효화/리패칭: 특정 쿼리를 무효화/리페칭할 때 사용
> 4. 중복 요청 방지 및 최적화: 동일한 쿼리 키로 여러 쿼리 요청이 동시에 발생할 경우, 첫 번째 요청이 완료될 때까지 추가 요청을 중단하고 첫 번째 요청의 결과를 재사용
