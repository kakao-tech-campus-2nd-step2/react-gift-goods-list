# 🚀 1단계 - API 적용하기

### 진행 방식

- 미션은 과제 진행 요구 사항, 요구 사항 두 가지로 구성되어 있습니다.
- 두 개의 요구 사항을 만족하기 위해 노력합니다. 특히 기능을 구현하기 전에 기능 목록을 만들고 어떻게 만들 것인지 고민해보세요.
- 기능 단위로 커밋하는 방식으로 진행합니다.
- 기능 요구 사항에 기재되지 않은 내용은 스스로 판단하여 구현합니다.

## 📝 주요 요구사항

1. 본인만의 기준으로 일관된 코드를 작성합니다.
2. 첨부된 `oas.yaml` 파일을 토대로 Request, Response Type을 정의합니다.
3. React Query를 사용하지 말고 axios를 사용해서 구현합니다.
4. 첨부된 `oas.yaml` 파일과 목 API URL을 사용하여 API를 구현합니다.

## 🚀 Getting Started

- ✔️ Frontend에서 비동기 데이터를 처리하는 방법에 대해 고민해요.
- ✔️ Axios 만을 사용해서 React에서 비동기 데이터를 구현해요.
- ✔️ Suspense, Error Boundary를 사용하지 않고 fetch State를 관리해봐요.

### 메인 페이지

1. **Theme 카테고리 섹션**

   - `/api/v1/themes` API를 사용하여 섹션을 구현합니다.
   - API는 Axios를 사용하여 구현합니다.

2. **실시간 급상승 선물랭킹 섹션**
   - `/api/v1/ranking/products` API를 사용하여 섹션을 구현합니다. (Axios 사용 가능)
   - 필터 조건을 선택하면 해당 조건에 맞게 API를 요청하여 보여지도록 합니다.

### Theme 페이지

1. **Header**

   - URL의 pathParams와 `/api/v1/themes` API를 사용하여 섹션을 구현합니다.
   - themeKey가 잘못된 경우 메인 페이지로 연결합니다.

2. **상품 목록 섹션**
   - `/api/v1/themes/{themeKey}/products` API를 사용하여 상품 목록을 구현합니다.
   - API 요청 시 한번에 20개의 상품 목록이 내려오도록 합니다.

## Getting Started

# 🚀 2단계 - Error, Loading Status 핸들링 하기

## 🚀 Getting Started

- ✔️ 비동기 데이터 요청 시 발생 할 수 있는 Loading, Error가 무엇이 있는지 생각하고 적용해봐요.
- ✔️ 유저 관점에서 Loading과 Error를 어떻게 전달하면 좋을지? 고민해봐요.

## 📝 Requirements

- 본인만의 기준으로 일관된 코드를 작성해주세요.
- 각 API에서 Loading 상태에 대한 UI 대응을 해요.
- 데이터가 없는 경우에 대한 UI 대응을 해요.
- Http Status에 따라 Error를 다르게 처리해요.

# 🚀 3단계 - 테마 별 선물 추천 API에 페이지네이션 구현하기 & React Query 사용해보기

## 🚀 Getting Started

- ✔️ 페이지네이션의 동작 원리를 이해하고 적용해요.
- ✔️ IntersectionObserver가 무엇인지 살펴보고 해당 기술을 사용하여 무한 스크롤을 설계해요.

## 📝 Requirements

- 본인만의 기준으로 일관된 코드를 작성해주세요.
- 스크롤을 내리면 추가로 데이터를 요청하여 보여지게 해요.
- 1단계에서 구현한 API를 react-query를 사용해서 구현해봐요.

# 🚀 4단계 - 질문의 답변을 README에 작성

## 아래 질문에 대한 답변을 README에 추가하여 과제 제출을 해요.

## 📝 Requirements

### 3주차 질문

### 질문 1. CORS 에러는 무엇이고 언제 발생하는지 설명해주세요. 이를 해결할 수 있는 방법에 대해서도 설명해주세요.

ORS 에러는 웹 브라우저에서 보안상의 이유로 발생한다. CORS는 Cross-Origin Resource Sharing의 약자로, 서로 다른 출처에서 리소스를 공유하는 것을 허용하거나 제한하는 메커니즘이다. CORS 정책은 브라우저가 스크립트에서 다른 도메인으로 요청을 보낼 때 발생할 수 있는 보안 문제를 방지하기 위해 존재한다. 예를 들어, 웹 페이지가 다른 도메인의 API에 요청을 보낼 때 CORS 정책을 따르지 않으면 브라우저는 요청을 차단하고 CORS 에러를 발생시킨다.

CORS 에러는 다음과 같은 상황에서 발생한다:

- 다른 도메인의 리소스에 접근하려고 할 때
- 서버가 올바른 CORS 헤더를 제공하지 않을 때
- 프리플라이트 요청이 실패할 때 (OPTIONS 메서드로 서버에 사전 요청을 보내 확인하는 과정)

해결 방법:

1. 서버에서 올바른 CORS 헤더 설정하기: 서버 측에서 Access-Control-Allow-Origin 헤더를 설정하여 특정 도메인 또는 모든 도메인(\*)에서의 요청을 허용한다.

   ```jsx
   from flask import Flask, request
   from flask_cors import CORS

   app = Flask(__name__)
   CORS(app)

   @app.route("/api/data")
   def data():
       return {"message": "Hello, World!"}

   ```

2. 프록시 서버 사용하기: 프론트엔드와 백엔드 사이에 프록시 서버를 두어 동일 출처 정책을 우회한다.

   ```jsx
   {
     "devServer": {
       "proxy": {
         "/api": {
           "target": "http://backend-server.com",
           "changeOrigin": true
         }
       }
     }
   }
   ```

3. JSONP 사용하기: JSONP는 CORS 정책을 우회하는 오래된 방법으로, script 태그를 이용해 서버에서 데이터를 가져오는 방식이다. 하지만, 보안상의 이유로 잘 사용되지 않는다.

### 질문 2. 비동기 처리 방법인 callback, promise, async await에 대해 각각 장단점과 함께 설명해주세요.

### Callback

- **장점**
  - 간단하고 직관적이다.
  - 즉시 실행된다.
- **단점**
  - 콜백 지옥(Callback Hell)으로 인한 코드 가독성 저하와 유지보수 어려움.
  - 에러 처리가 어렵다.

### Promise

- **장점**
  - 콜백 지옥을 피할 수 있다.
  - 체이닝을 통해 가독성이 향상된다.
  - 에러 처리가 용이하다 (catch 사용).
- **단점**
  - 구문이 약간 복잡하다.
  - 여러 개의 프로미스를 병렬로 처리하는 경우 코드가 복잡해질 수 있다.

### Async/Await

- **장점**
  - 비동기 코드를 동기 코드처럼 작성할 수 있어 가독성이 매우 좋다.
  - 에러 처리가 간단하다 (try/catch 사용).
- **단점**
  - 구형 브라우저에서는 지원하지 않는다.
  - 여러 개의 비동기 작업을 병렬로 처리하기 위해서는 Promise.all과 같은 별도의 처리가 필요하다.

### 질문 3. react query의 주요 특징에 대해 설명하고, queryKey는 어떤 역할을 하는지 설명해주세요.

### React Query 주요 특징

- **데이터 패칭 및 캐싱**: 서버 상태를 간단하게 관리하고, 데이터를 캐싱하여 네트워크 요청을 줄인다.
- **자동 리패칭**: 데이터가 변경되었을 때 자동으로 리패칭하여 최신 상태를 유지한다.
- **배경 데이터 업데이트**: 사용자 인터페이스를 방해하지 않고 배경에서 데이터를 업데이트한다.
- **서버 상태 동기화**: 서버와 클라이언트의 상태를 쉽게 동기화한다.
- **사용자 친화적인 API**: 간단하고 직관적인 API로 사용성이 뛰어나다.

### queryKey의 역할

- **식별자 역할**: 각 쿼리를 고유하게 식별하여 캐싱 및 리패칭 로직을 효율적으로 관리한다.
- **디펜던시 관리**: queryKey를 기반으로 쿼리의 종속성을 관리하여, 관련된 데이터가 변경될 때 자동으로 리패칭된다.
- **메모이제이션**: queryKey를 통해 쿼리 결과를 메모이제이션하여 불필요한 네트워크 요청을 줄인다.
