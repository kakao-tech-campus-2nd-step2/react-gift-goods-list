## **경북대 FE\_정솔빈\_2주차 과제 Week 3**

### 1단계 - API 적용하기

**할 일 목록:**

- [x] Request, Response Type 정의, API 구현
- [x] 메인 페이지 - Theme 카테고리 섹션
  - [x] /api/v1/themes API를 사용하여 section을 구현
- [x] 메인 페이지 - 실시간 급상승 선물 랭킹 섹션
  - [x] /api/v1/ranking/products API를 사용하여 section 구현
  - [x] 필터 조건을 선택하면 해당 조건에 맞게 API를 요청해서 보이도록 구현
- [x] Theme 페이지 - header
  - [x] url의 pathParams와 /api/v1/themes API를 사용하여 section을 구현
  - [x] themeKey가 잘못된 경우 메인 페이지로 연결
- [x] Theme 페이지 - 상품 목록 섹션
  - [x] /api/v1/themes/{themeKey}/products API를 사용하여 상품 목록 구현
  - [x] API 요청 시 한번에 20개의 상품 목록이 내려오도록 구현

### 2단계 - Error, Loading Status 핸들링 하기

**할 일 목록:**

- [x] 각 API에서 Loading 상태에 대한 UI 대응
- [x] 데이터가 없는 경우에 대한 UI 대응
- [x] Http Status에 따라 Error를 다르게 처리

### 3단계 - 테마 별 선물 추천 API에 페이지네이션 구현하기 & React Query 사용해보기

**할 일 목록:**

- [x] 스크롤 내리면 추가로 데이터를 요청하여 보여지도록 구현하기
- [x] 1단계에서 구현한 API를 react-query를 사용해서 구현하기

---

### 4단계 - 질문의 답변을 README에 작성

**1. CORS 에러는 무엇이고 언제 발생하는지 설명해주세요. 이를 해결할 수 있는 방법에 대해서도 설명해주세요.**

CORS (Cross-Origin Resource Sharing)는 웹 어플리케이션에서 다른 도메인의 리소스에 접근할 때 발생하는 보안 이슈를 해결하기 위한 표준 방법입니다. 즉, 영어 의미 그대로 엇갈린 다른 출처로 인한 에러를 의미합니다. 웹 브라우저는 HTTP 요청에 대해서 각기 다른 특징을 가지고 있기 때문에 이러한 에러가 발생합니다. 동일 출처 정책 (Same-Origin Policy)은 동일한 출처(URL) 서버에 있는 리소스는 가져올 수 있지만 다른 출처(Cross-Origin) 서버에 있는 이미지와 유튜브 영상 같은 리소스는 상호작용이 불가능합니다. 이때 출처는 Protocol, Host, Port로 동일함을 판단합니다. 예를 들어 <img>, <video>, <script>, <link> 태그 는 Cross-Origin 정책을 지원하고 Fetch API 스크립트는 Same-Origin 정책을 따릅니다.

동작 원리를 알아보자면

1.  클라이언트 HTTP 요청의 헤더에 Origin 정보를 담어서 보냅니다.

_이때까지 헤더의 역할을 제대로 이해하지 않고 사용한 것 같아 반성합니다.._

HTTP 헤더는 저장되거나 전송되는 데이터 블록의 맨 앞에 위치한 데이터를 의미하며 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 합니다.

웹이 HTTP 프로토콜을 이용하여 서버의 요청을 보낼 때 브라우저는 요청 헤더에 Origin이라는 필드에 출처를 함께 보냅니다.

2.  서버 응답 헤더에 Acces-Control-Allow-Origin 정보를 클라이언트로 보냅니다.

여기서 Acces-Control-Allow-Origin이란 응답 헤더 중 하나로, 다른 도메인에서 요청하는 경우 어떤 도메인에서 요청을 허용할 것인지를 명시합니다.
예를 들어, 서버 A에서 도메인이 www.abc.com인데 다른 도메인에서 이 자원에 접근하려는 경우, www.abc.com 서버에서 Acces-Control-Allow-Origin 헤더에 접근하고자 하는 다른 도메인을 명시해 요청을 허용할 수 있습니다.

3.  비교
    요청할 때 보낸 Origin 정보와 서버에 보낸 Acces-Control-Allow-Origin 정보를 비교해서 서버에서 보내준 Acces-Control-Allow-Origin의 차단 유무를 결정합니다. 만약 유효하지 않다면 그 응답을 사용하지 않고 버리는데 이때 CORS 에러가 발생합니다!

이러한 에러를 해결하기 위해서 서버에서 Access-Control-Allow-Origin 헤더를 직접 세팅에 해결할 수 있습니다. CORS의 동작원리를 통해 해결방법을 생각했을 때 가장 명확하게 해결할 수 있는 방법이라고 생각합니다.

또, 요청해야하는 URL 앞에 프록시 서버 URL을 붙혀 요청하게 되면 해결할 수 있습니다.

여기서 프록시(Proxy) 서버란 클라이언트가 자신을 거쳐 다른 네트워크에 접속할 수 있도록 중간에서 대리로 통신해주는 서버를 의미합니다.

```
클라이언트에서 프록시 서버로 데이터를 전송 -> 프록시 서버에서 다시 웹 서버로 웹 요청 -> 웹 서버에서 프록시 서버로 웹 응답 -> 프록시 서버에서 클라이언트로 데이터 전송
```

마지막으로 Chrome의 확장 프로그램을 이용하여 해결할 수 있습니다.

**2. 비동기 처리 방법인 callback, promise, async await에 대해 각각 장단점과 함께 설명해주세요.**

**Callback** 함수는 특정 작업이 완료된 후 나중에 호출할 함수를 의미합니다. 비동기 작업의 결과를 처리하기 위해 사용됩니다. 비동기 처리를 간단하게 할 수 있다는 장점이 있지만, 여러 비동기 작업은 연속적으로 실행할 때 중첨된 콜백 함수로 콜백 지옥이 됩니다. 또한, 에러를 처리하는게 번거롭다는 단점이 있습니다.
중첩이 많지 않은 경우 콜백 지옥을 피할 수 있기 때문에 빠르게 작동하도록 콜백 함수를 사용하면 좋을 것 같습니다.

**promise**는 비동기 작업의 완료 또느 실패를 나타내는 객체입니다. 성공 시 `.then()`, 실패 시 `.catch()`로 결과를 나타냅니다. 중첩된 콜백을 피할 수 있고, `.catch()`를 이용해 일관된 방식으로 에러를 처리할 수 있습니다. 또한 여러 비동기 작업을 순차적으로 처리하기 용이하다는 장점이 있습니다. 하지만 구문이 복잡하거나 `.then()`때문에 가독성이 떨어진다는 단점이 있습니다.
비동기 작업을 순차적으로 처리해야할 때 프로미스를 사용하면 좋을 것 같습니다.

**async await**는 promise를 더 간결하게 작성할 수 있습니다. `async` 함수는 프로미스를 반환하고, `await`는 프로미스가 해결을 기다립니다. 제일 처음 언급한 것 처럼 간결하고 동기 방식처럼 보인다는 장점이 있어 가독성이 좋습니다. 또한 `try/catch`를 이용한 예외 처리로 위의 다른 방식과 달리 직관적입니다. 다만 구형 브라우저에서는 폴리필이 필요할 수 있다는 단점이 있습니다. 가장 많은 장점을 가지고 있어 이번 과제 코드에서 `async await`를 사용하였습니다.
복잡한 비동기 작업에서 가독성을 높이기 위해 async await를 이용하면 좋을 것 같습니다. 가장 많은 장점과 구형 브라우저에서만 사용이 안된다는 단점만으로 아마 가장 많이 사용되지 않을까 생각합니다.

**3. react query의 주요 특징에 대해 설명하고, queryKey는 어떤 역할을 하는지 설명해주세요.**

React Query는 데이터 Fetching, caching, 동기화, 서버 데이터 업데이트 등을 쉽게 만들어주는 라이브러리입니다. Redux를 사용하면 최소한의 변경으로 여러 곳에 재사용되지만 반복적인 코드로 많은 양의 코드가 생긴다는 문제가 발생합니다. React query는 비교적 코드의 양이 적고 단순해 유지 보수가 용이합니다. 즉, 같은 데이터의 중복 요청을 제거하고 가비지 컬렉션을 이용해 서버의 데이터 메모리를 관리해줍니다. 데이터를 자동 페칭, 캐싱 해주며 서버 상태가 변경되었을 대도 클라이언트 상태를 자동으로 동기화해줍니다.

querykey는 데이터를 캐싱하는 역할을 합니다. 같은 쿼리키를 가진 쿼리는 동일한 데이터를 공유하기 때문에 불필요한 서버 요청을 줄일 수 있습니다. 또한, query data에 고유하기 때문에 여러 쿼리를 식별할 수 있습니다.

---

### 코드 작성하면서 어려웠던 점

- CORS의 동작 원리를 알아보는 과정에서 HTTP 요청과 응답의 상호작용에 대해 이해하기 어려웠습니다. 서버와 브라우저 간의 상호작용에서 처음 알게 된 내용들이 많았습니다😢

- react query 사용한다면 코드가 더 간단해져야하는데 react query를 이번 과제에서 효과적으로 사용하지 못한 것 같습니다.. 코드에서 개선해야 할 점을 알려주시면 감사하겠습니다!

### 마무리 및 질문

**1. Unexpected Application Error를 어떻게 해결할 수 있을까요?**
홈 화면에서 처음 각 테마 중 하나를 눌러서 테마 페이지로 이동하면 Unexpected Application Error가 발생합니다. 다시 이전 화면으로 돌아가서 테마를 누르면 정상적으로 코드가 작동됩니다.

시도1. 오류 페이지에서 동기 입력에 응답하면서 컴포넌트가 중단되었고, startTrannsition을 사용하여 중단을 최소화할 수 있다고 해서 startTransition을 이용했지만 똑같은 오류가 발생합니다.

긴 내용 읽어주셔서 감사합니다~!
