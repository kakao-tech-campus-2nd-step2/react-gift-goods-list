# 카카오 테크 캠퍼스 - 프론트엔드 카카오 선물하기 편

## Week 3. 1단계 - API 적용하기

### 📝Requirements

- [x] 첨부된 **`oas.yaml`** 파일을 토대로 Request, Response Type을 정의
- [x] 메인 페이지 - Theme 카테고리 섹션
- [x] 메인 페이지 -실시간 급상승 선물랭킹 섹션
- [x] Theme 페이지 - header
- [x] Theme 페이지 - 상품 목록 섹션

## Week 3. 2단계 - Error, Loading Status 핸들링 하기

### 📝Requirements

- [x] 각 API에서 Loading 상태에 대한 UI 대응
- [x] 데이터가 없는 경우에 대한 UI 대응
- [x] Http Status에 따라 Error를 다르게 처리

## Week 3. 3단계 - 테마 별 선물 추천 API에 페이지네이션 구현하기 & React Query 사용해보기

### 📝Requirements

- [x] 스크롤을 내리면 추가로 데이터를 요청하여 보여지게
- [x] 1단계에서 구현한 API를 react-query를 사용해서 구현

## Week 3. 4단계 - 질문의 답변을 README에 작성

### 📝Requirements

질문 1. CORS 에러는 무엇이고 언제 발생하는지 설명해주세요. 이를 해결할 수 있는 방법에 대해서도 설명해주세요

- CORS (Cross-Origin Resource Sharing) 에러는 웹 페이지가 다른 도메인, 프로토콜 또는 포트에서 리소스를 요청할 때나 서버가 CORS 정책을 통해 요청을 허용하지 않을 때
  발생한다. 예를 들어, http://example.com에서 호스팅된 웹 페이지가 http://api.example.com에서 리소스를 요청할 때 CORS 에러가 발생할 수 있다. 이를 해결하기 위해서는 서버측에서 적절한 CORS 헤더를 설정하여 요청을 허용하는 방식이 가장 바람직하다.

질문 2. 비동기 처리 방법인 callback, promise, async await에 대해 각각 장단점과 함께 설명해주세요

- **콜백 (Callback)**

  장점:
  간단하고 이해하기 쉬움.
  즉각적인 비동기 처리를 가능하게 함.

  단점:
  콜백 지옥(Callback Hell)이라고 불리는 중첩된 구조로 인해 코드가 복잡하고 가독성이 떨어짐.
  에러 처리가 어렵고 코드 유지보수가 힘듦.

- **프로미스 (Promise)**

  장점:
  콜백 지옥 문제 해결 가능.
  체이닝을 통해 가독성이 높은 코드 작성 가능.

  단점:
  여러 프로미스를 병렬로 처리할 때 코드가 복잡해질 수 있음.

- **async/await**

  장점:
  동기 코드처럼 읽기 쉽고 이해하기 쉬움.
  콜백 지옥 문제와 프로미스 체이닝의 복잡성 해결 가능.

  단점:
  오래된 브라우저에서는 지원하지 않음.

질문 3. react query의 주요 특징에 대해 설명하고, queryKey는 어떤 역할을 하는지 설명해주세요

- **React Query**는 서버 상태를 관리하는 라이브러리로, 데이터 페칭, 캐싱, 동기화 및 서버 상태의 업데이트를 효율적으로 처리해준다.

- **React Query의 주요 특징**

  1. 데이터 페칭 및 캐싱: 서버 상태를 효율적으로 관리하며 데이터를 자동으로 캐싱하고, 캐시된 데이터를 기반으로 UI를 즉각적으로 업데이트한다.
  2. 자동화된 리페칭: 데이터가 백그라운드에서 자동으로 업데이트되어 최신 상태를 유지한다.
  3. 간편한 에러 핸들링: 전역 및 개별 쿼리 수준에서 에러를 쉽게 처리할 수 있다.
  4. 의존성 관리: 쿼리 간의 의존성을 관리하여 데이터 일관성을 유지한다.
  5. 서버 상태 동기화: 서버 상태와 클라이언트 상태를 동기화하여 최신 데이터를 유지한다.

- queryKey는 React Query에서 특정 쿼리를 식별하는 고유한 키이다.

- **queryKey의 역할**

  1. 캐싱 및 데이터 식별: queryKey를 사용하여 쿼리를 고유하게 식별하고, 해당 키를 기준으로 데이터를 캐싱한다.
  2. 리페칭 제어: queryKey를 기준으로 데이터를 리페칭할 수 있으며, 키가 변경될 때 자동으로 데이터를 업데이트한다.
  3. 의존성 관리: 쿼리 간 의존성을 관리하여, 특정 쿼리의 키가 변경될 때 관련된 데이터를 자동으로 갱신한다.
